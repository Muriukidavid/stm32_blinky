/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2022-01-29

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "stm32f10x.h"
#include "stm32f10x_rcc.h"
#include <stdio.h>

void gpio_toggle(void);
void GPIOA_Init(void);
void delay(uint32_t ms);
void USART1_Init(void);
void OutString(char *s);
void setSystemFreq(void);

RCC_ClocksTypeDef RCC_Clocks;

int main(void)
{
	char str[100] = {0};

	//setSystemFreq();

	//SystemCoreClockUpdate();

	RCC_GetClocksFreq(&RCC_Clocks);

	GPIOA_Init();

	USART1_Init();

	OutString("Welcome to  F103C8 test\r\n");
	sprintf(str, "Running at %d MHz\n", (int)(RCC_Clocks.SYSCLK_Frequency / 1000000));
	OutString(str);

	/* Infinite loop */
	while (1);
}

void OutString(char *s)
{
  while(*s)
  {
    while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); // Wait for Empty

    USART_SendData(USART1, *s++); // Send Char
    while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); //wait for data to be sent
  }
}


void USART1_IRQHandler(void)
{
    /* RXNE handler */
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        /* If received 't', toggle LED and transmit 'T' */
        if((char)USART_ReceiveData(USART1) == 't')
        {
            gpio_toggle();
            USART_SendData(USART1, 'T');
            /* Wait until Tx data register is empty, not really
             * required for this example but put in here anyway.
             */

            while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
            {
            }
        }
    }

    /* ------------------------------------------------------------ */
    /* Other USART1 interrupts handler can go here ...             */
}

void USART1_Init(void)
{
	//RCC_HSEConfig();

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA |RCC_APB2Periph_AFIO, ENABLE);
	delay(2); //seconds delay

	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef pin_settings;

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	// Set PTA10 as RX pin (AF)
	pin_settings.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//Input Floating Mode
	pin_settings.GPIO_Pin	= GPIO_Pin_10;			//PTA10 as USART1_RX input
	pin_settings.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_Init(GPIOA, &pin_settings);

	// Set PA9 as TX PIN (AF)
	pin_settings.GPIO_Mode = GPIO_Mode_AF_PP; //GPIO_Mode_AF_PP; GPIO_Mode_AF_OD;	//Output Push Pull Mode -> drives another device
	pin_settings.GPIO_Pin	= GPIO_Pin_9;			//PTA9 as USART1_TX output
	pin_settings.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_Init(GPIOA, &pin_settings);

	//enable SART1 and configure it
	USART_Cmd(USART1, ENABLE);
	delay(2); //seconds delay
	USART_Init(USART1, &USART_InitStructure);
	delay(2); //seconds delay
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

	NVIC_EnableIRQ(USART1_IRQn);
	NVIC_ClearPendingIRQ(USART1_IRQn);
}

void GPIOA_Init(void)
{
    /* Bit configuration structure for GPIOA PIN8 */
    GPIO_InitTypeDef gpioa_init_struct = { GPIO_Pin_8, GPIO_Speed_10MHz,
                                           GPIO_Mode_Out_PP };

    /* Enable PORT A clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    /* Initialize GPIOA: 50MHz, PIN8, Push-pull Output */
    GPIO_Init(GPIOA, &gpioa_init_struct);

    /* Turn off GPIO at the beginning */
    GPIO_SetBits(GPIOA, GPIO_Pin_8);
}

void gpio_toggle(void)
{
    /* Read GPIO output (GPIOA PIN8) status */
    uint8_t led_bit = GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_8);

    /* If GPIO output set, clear it */
    if(led_bit == (uint8_t)Bit_SET)
    {
        GPIO_ResetBits(GPIOA, GPIO_Pin_8);
    }
    /* If GPIO output clear, set it */
    else
    {
        GPIO_SetBits(GPIOA, GPIO_Pin_8);
    }
}

void delay(uint32_t ms){
	RCC_GetClocksFreq(&RCC_Clocks);

	uint32_t freq = (uint32_t)RCC_Clocks.SYSCLK_Frequency/10;// 8Mhz, or 72Mhz

	uint32_t j=0, k=0;
	while(k<=ms)
	{
		j = freq;
		while(j>=0)
		{
			asm("NOP");
			j++;
		}
		k++;
	}
}

void setSystemFreq()
{
	RCC->CIR = 0x009F0000;
	// Turn HSE ON
	RCC->CR |= RCC_CR_HSEON;
	// Wait Until HSE Is Ready
	while (!(RCC->CR & RCC_CR_HSERDY))
		;

    //set HSE as system clock
    RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_SW)) | RCC_CFGR_SW_HSE;

    //AHB prescaler
    RCC->CFGR &= ~(RCC_CFGR_HPRE); //remove old prescaler
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1; //set AHB prescaler = 1.
    //set ADC prescaler = 8
    RCC->CFGR &= ~(RCC_CFGR_ADCPRE);
    RCC->CFGR |= RCC_CFGR_ADCPRE_DIV8;
    //set APB1 prescaler
    RCC->CFGR &= ~(RCC_CFGR_PPRE1);
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
    //set APB2 prescaler
    RCC->CFGR &= ~(RCC_CFGR_PPRE2);
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

    //set flash wait states to 2 wait states
    FLASH->ACR &= ~(FLASH_ACR_LATENCY);
    FLASH->ACR |= FLASH_ACR_LATENCY_2;

    //Set PLL Multiplier
    //RCC->CFGR |= 0b1100 << 18;
    //at HSE=8MHz, 8*9 = 72MHz.
    RCC->CFGR &= ~(RCC_CFGR_PLLMULL);
    RCC->CFGR |= RCC_CFGR_PLLMULL9;

    // //Set HSE as PLL Source. bit set -> HSE, bit unser -> HSI
    RCC->CFGR |= RCC_CFGR_PLLSRC;

    // Set HSE Prescaler On PLL Entry
    RCC->CFGR &= ~RCC_CFGR_PLLXTPRE;
    RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE; //no HSE prescaler before PLL entry

    RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_SW)) | RCC_CFGR_SW_PLL;

    // Clear All Interrupts
    RCC->CIR = 0x009F0000;
}
